<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Super Resolution - Tiled Inference</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .container {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }

    .panel {
      flex: 1;
      min-width: 400px;
    }

    canvas {
      max-width: 100%;
      border: 1px solid #ccc;
      margin-top: 10px;
      cursor: crosshair;
    }

    button {
      padding: 10px 20px;
      margin: 10px 0;
      font-size: 16px;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    input[type="file"] {
      margin: 10px 0;
    }

    #progress {
      margin: 10px 0;
      font-weight: bold;
    }

    #debugInfo {
      margin-top: 10px;
      font-family: monospace;
      font-size: 11px;
      background: #f5f5f5;
      padding: 10px;
      border-left: 3px solid #007acc;
      max-height: 200px;
      overflow-y: auto;
    }

    .progress-bar {
      width: 100%;
      height: 20px;
      background: #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
      margin: 10px 0;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #45a049);
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 12px;
      font-weight: bold;
    }
  </style>
</head>

<body>
  <h1>Super Resolution - Tiled Inference (Web Worker)</h1>

  <div class="container">
    <div class="panel">
      <h3>Input Image <span id="inputInfo"></span></h3>
      <input type="file" id="imageInput" accept="image/*">
      <div style="position: relative;">
        <canvas id="inputCanvas"></canvas>
      </div>
    </div>

    <div class="panel">
      <h3>Output Image <span id="outputInfo"></span></h3>
      <button id="runBtn" disabled>Run Inference</button>
      <button id="cancelBtn" style="display: none;">Cancel</button>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%">0%</div>
      </div>
      <div id="progress"></div>
      <div id="debugInfo">Waiting for model...</div>
      <canvas id="outputCanvas"></canvas>
    </div>
  </div>

  <script id="worker-script" type="text/js-worker">
    importScripts('https://cdn.jsdelivr.net/npm/onnxruntime-web@1.20.1/dist/ort.min.js');

    let ortSession = null;

    ort.env.wasm.wasmPaths = 'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.20.1/dist/';
    ort.env.wasm.numThreads = 1; 

    self.onmessage = async function(e) {
      const {type, data} = e.data;
      
      if (type === 'loadModel') {
        try {
          const modelBuffer = data;
          ortSession = await ort.InferenceSession.create(modelBuffer, {
            executionProviders: ['wasm'],
            graphOptimizationLevel: 'all'
          });
          self.postMessage({type: 'modelLoaded', success: true});
        } catch (err) {
          self.postMessage({type: 'modelLoaded', success: false, error: err.message});
        }
      }
      
      if (type === 'runInference') {
        try {
          const {patchData, width, height} = data;
          const inputTensor = new ort.Tensor('float32', patchData, [1, 3, height, width]);
          
          const feeds = {[ortSession.inputNames[0]]: inputTensor};
          const results = await ortSession.run(feeds);
          
          const outputTensor = results[ortSession.outputNames[0]];
          const outputData = Array.from(outputTensor.data);
          const outHeight = outputTensor.dims[2];
          const outWidth = outputTensor.dims[3];
          
          self.postMessage({
            type: 'inferenceResult',
            data: {outputData, outWidth, outHeight}
          });
        } catch (err) {
          self.postMessage({type: 'inferenceError', error: err.message});
        }
      }
    };
  </script>

  <script>
    const TILE_SIZE = 96;
    const TILE_OVERLAP = 6;
    const SCALE = 4;

    let worker = null;
    let inputImageData = null;
    let inputCanvasCtx = null;
    let isCancelled = false;

    function createWorker() {
      const workerScript = document.getElementById('worker-script').textContent;
      const blob = new Blob([workerScript], {type: 'application/javascript'});
      return new Worker(URL.createObjectURL(blob));
    }

    async function loadModel() {
      try {
        worker = createWorker();

        const response = await fetch('./srragan_psnr_nobn_2.onnx');
        const modelBuffer = await response.arrayBuffer();

        worker.postMessage({type: 'loadModel', data: modelBuffer});

        worker.onmessage = function (e) {
          const {type, success, error} = e.data;
          if (type === 'modelLoaded') {
            if (success) {
              const debugInfo = 'Model loaded successfully in Web Worker\nUI should remain responsive during inference';
              console.log(debugInfo);
              document.getElementById('debugInfo').textContent = debugInfo;
            } else {
              document.getElementById('debugInfo').textContent = `Error: ${error}`;
            }
          }
        };
      } catch (err) {
        console.error("Model load failed:", err);
        document.getElementById('debugInfo').textContent = `Error: ${err.message}`;
      }
    }

    document.getElementById('imageInput').addEventListener('change', function (e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (event) {
        const img = new Image();
        img.onload = function () {
          const inputCanvas = document.getElementById('inputCanvas');

          inputCanvas.width = img.width;
          inputCanvas.height = img.height;

          inputCanvasCtx = inputCanvas.getContext('2d');

          inputCanvasCtx.drawImage(img, 0, 0);
          inputImageData = inputCanvasCtx.getImageData(0, 0, img.width, img.height);

          document.getElementById('inputInfo').textContent = `(${img.width}×${img.height})`;
          document.getElementById('runBtn').disabled = false;
          document.getElementById('debugInfo').textContent += `\nImage loaded: ${img.width}×${img.height}`;
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    function highlightTile(x1, y1, x2, y2, progressText) {
      if (!inputCanvasCtx || !inputImageData) return;

      inputCanvasCtx.putImageData(inputImageData, 0, 0);

      inputCanvasCtx.fillStyle = 'rgba(0, 255, 0, 0.2)';
      inputCanvasCtx.fillRect(x1, y1, x2 - x1, y2 - y1);

      inputCanvasCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
      inputCanvasCtx.lineWidth = 2;
      inputCanvasCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);

      document.getElementById('progress').textContent = progressText;
    }

    document.getElementById('runBtn').addEventListener('click', async function () {
      if (!inputImageData || !worker) return;

      const runBtn = document.getElementById('runBtn');
      const cancelBtn = document.getElementById('cancelBtn');
      runBtn.disabled = true;
      cancelBtn.style.display = 'inline-block';
      isCancelled = false;

      try {
        const outputData = await runTiledInference(inputImageData);
        if (!isCancelled) {
          displayOutput(outputData);
          document.getElementById('progress').textContent = '✅ Done!';
          updateProgressBar(100);
        }
      } catch (err) {
        console.error("Inference failed:", err);
        if (!isCancelled) {
          alert(`Inference failed: ${err.message}`);
        }
      } finally {
        runBtn.disabled = false;
        cancelBtn.style.display = 'none';
      }
    });

    document.getElementById('cancelBtn').addEventListener('click', function () {
      isCancelled = true;
      document.getElementById('progress').textContent = '❌ Cancelled';
    });

    function updateProgressBar(percent) {
      const fill = document.getElementById('progressFill');
      fill.style.width = `${percent}%`;
      fill.textContent = `${Math.round(percent)}%`;
    }

    async function runTiledInference(imageData) {
      const {width, height} = imageData;
      const outputWidth = width * SCALE;
      const outputHeight = height * SCALE;

      const outputCanvas = document.getElementById('outputCanvas');
      outputCanvas.width = outputWidth;
      outputCanvas.height = outputHeight;

      const outputImageData = new ImageData(outputWidth, outputHeight);
      const step = TILE_SIZE - TILE_OVERLAP;
      const tilesY = Math.ceil(height / step);
      const tilesX = Math.ceil(width / step);
      const totalTiles = tilesY * tilesX;

      let tileCount = 0;

      for (let y = 0; y < height; y += step) {
        for (let x = 0; x < width; x += step) {
          if (isCancelled) {
            throw new Error('Cancelled by user');
          }

          const y1 = y;
          const x1 = x;
          const y2 = Math.min(y1 + TILE_SIZE, height);
          const x2 = Math.min(x1 + TILE_SIZE, width);

          tileCount++;
          const percent = (tileCount / totalTiles) * 100;
          const progressText = `Processing tile ${tileCount}/${totalTiles}`;

          highlightTile(x1, y1, x2, y2, progressText);
          updateProgressBar(percent);

          const patch = extractPatch(imageData, x1, y1, x2, y2);
          const srPatch = await runModelWorker(patch);

          const dy1 = y1 * SCALE;
          const dx1 = x1 * SCALE;
          placePatch(outputImageData, srPatch, dx1, dy1);

          displayOutput(outputImageData);
        }
      }

      inputCanvasCtx.putImageData(inputImageData, 0, 0);
      return outputImageData;
    }

    function extractPatch(imageData, x1, y1, x2, y2) {
      const width = x2 - x1;
      const height = y2 - y1;
      const patch = new Float32Array(3 * height * width);

      for (let y = y1; y < y2; y++) {
        for (let x = x1; x < x2; x++) {
          const srcIdx = (y * imageData.width + x) * 4;
          const localY = y - y1;
          const localX = x - x1;
          const baseIdx = localY * width + localX;

          patch[baseIdx] = (imageData.data[srcIdx] / 127.5) - 1.0;
          patch[height * width + baseIdx] = (imageData.data[srcIdx + 1] / 127.5) - 1.0;
          patch[2 * height * width + baseIdx] = (imageData.data[srcIdx + 2] / 127.5) - 1.0;
        }
      }

      return {data: patch, width, height};
    }

    function runModelWorker(patch) {
      return new Promise((resolve, reject) => {
        const {data, width, height} = patch;

        worker.postMessage({
          type: 'runInference',
          data: {patchData: Array.from(data), width, height}
        });

        const handler = function (e) {
          const {type, data, error} = e.data;

          if (type === 'inferenceResult') {
            worker.removeEventListener('message', handler);

            const {outputData, outWidth, outHeight} = data;
            const rgbData = new Uint8ClampedArray(outHeight * outWidth * 3);

            for (let i = 0; i < outputData.length; i++) {
              const val = Math.max(-1, Math.min(1, outputData[i]));
              rgbData[i] = Math.round((val + 1) * 127.5);
            }

            resolve({data: rgbData, width: outWidth, height: outHeight});
          } else if (type === 'inferenceError') {
            worker.removeEventListener('message', handler);
            reject(new Error(error));
          }
        };

        worker.addEventListener('message', handler);
      });
    }

    function placePatch(outputImageData, patch, dx1, dy1) {
      const {data, width: patchWidth, height: patchHeight} = patch;
      const outWidth = outputImageData.width;
      const outData = outputImageData.data;

      const channelSize = patchWidth * patchHeight;

      for (let y = 0; y < patchHeight; y++) {
        for (let x = 0; x < patchWidth; x++) {
          const pixelIdx = y * patchWidth + x;

          const r = data[pixelIdx];
          const g = data[channelSize + pixelIdx];
          const b = data[2 * channelSize + pixelIdx];

          const dstIdx = ((dy1 + y) * outWidth + (dx1 + x)) * 4;

          outData[dstIdx] = r;
          outData[dstIdx + 1] = g;
          outData[dstIdx + 2] = b;
          outData[dstIdx + 3] = 255;
        }
      }
    }

    function displayOutput(imageData) {
      const outputCanvas = document.getElementById('outputCanvas');
      const ctx = outputCanvas.getContext('2d');
      ctx.putImageData(imageData, 0, 0);
      document.getElementById('outputInfo').textContent = `(${imageData.width}×${imageData.height})`;
    }

    loadModel();
  </script>
</body>

</html>