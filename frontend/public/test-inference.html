<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ONNX Inference Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .panel {
            border: 1px solid #ccc;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        canvas {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            margin: 10px 0;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .run-btn {
            background-color: #4CAF50;
            color: white;
        }
        .cancel-btn {
            background-color: #f44336;
            color: white;
        }
    </style>
</head>
<body>
    <h1>ONNX Super Resolution Test</h1>
    
    <div class="panel">
        <h3>Input Image</h3>
        <input type="file" id="imageInput" accept="image/*">
        <canvas id="inputCanvas"></canvas>
        <div id="inputInfo"></div>
    </div>
    
    <div class="panel">
        <h3>Output Image <span id="outputInfo"></span></h3>
        <button id="runBtn" class="run-btn" disabled>Run Inference</button>
        <button id="cancelBtn" class="cancel-btn" style="display: none;">Cancel</button>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%">0%</div>
        </div>
        <div id="progress"></div>
        <div id="debugInfo">Waiting for model...</div>
        <canvas id="outputCanvas"></canvas>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.20.1/dist/ort.min.js"></script>
    <script>
        // Constants from original
        const TILE_SIZE = 96;
        const TILE_OVERLAP = 6;
        const SCALE = 4;
        
        let ortSession = null;
        let inputImageData = null;
        let inputCanvasCtx = null;
        let isCancelled = false;
        let worker = null;

        // Initialize ONNX Runtime
        ort.env.wasm.wasmPaths = 'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.20.1/dist/';
        ort.env.wasm.numThreads = 1;

        // Create worker from embedded script
        const workerScript = `
            importScripts('https://cdn.jsdelivr.net/npm/onnxruntime-web@1.20.1/dist/ort.min.js');

            let ortSession = null;

            ort.env.wasm.wasmPaths = 'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.20.1/dist/';
            ort.env.wasm.numThreads = 1; 

            self.onmessage = async function(e) {
                const {type, data} = e.data;
                
                if (type === 'loadModel') {
                    try {
                        const modelBuffer = data;
                        ortSession = await ort.InferenceSession.create(modelBuffer, {
                            executionProviders: ['wasm'],
                            graphOptimizationLevel: 'all'
                        });
                        self.postMessage({type: 'modelLoaded', success: true});
                    } catch (err) {
                        self.postMessage({type: 'modelLoaded', success: false, error: err.message});
                    }
                }
                
                if (type === 'runInference') {
                    try {
                        const {patchData, width, height} = data;
                        const inputTensor = new ort.Tensor('float32', patchData, [1, 3, height, width]);
                        
                        const feeds = {[ortSession.inputNames[0]]: inputTensor};
                        const results = await ortSession.run(feeds);
                        
                        const outputTensor = results[ortSession.outputNames[0]];
                        const outputData = Array.from(outputTensor.data);
                        const outHeight = outputTensor.dims[2];
                        const outWidth = outputTensor.dims[3];
                        
                        self.postMessage({
                            type: 'inferenceResult',
                            data: {outputData, outWidth, outHeight}
                        });
                    } catch (err) {
                        self.postMessage({
                            type: 'inferenceError',
                            error: err.message
                        });
                    }
                }
            }
        `;

        const blob = new Blob([workerScript], { type: 'application/javascript' });
        worker = new Worker(URL.createObjectURL(blob));

        // Load model
        async function loadModel() {
            try {
                document.getElementById('debugInfo').textContent = 'Loading model...';
                const response = await fetch('/models/srgan.onnx');
                if (!response.ok) {
                    throw new Error('Failed to load model');
                }
                const modelBuffer = await response.arrayBuffer();
                
                return new Promise((resolve, reject) => {
                    worker.postMessage({ type: 'loadModel', data: modelBuffer });
                    
                    const handler = function(e) {
                        const {type, success, error} = e.data;
                        if (type === 'modelLoaded') {
                            worker.removeEventListener('message', handler);
                            if (success) {
                                resolve();
                            } else {
                                reject(new Error(error));
                            }
                        }
                    };
                    
                    worker.addEventListener('message', handler);
                });
            } catch (error) {
                console.error('Error loading model:', error);
                throw error;
            }
        }

        // Initialize
        loadModel().then(() => {
            document.getElementById('debugInfo').textContent = 'Model loaded successfully';
            document.getElementById('runBtn').disabled = false;
        }).catch(err => {
            document.getElementById('debugInfo').textContent = `Error: ${err.message}`;
        });

        // Image input handler
        document.getElementById('imageInput').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (event) {
                const img = new Image();
                img.onload = function () {
                    const inputCanvas = document.getElementById('inputCanvas');

                    inputCanvas.width = img.width;
                    inputCanvas.height = img.height;

                    inputCanvasCtx = inputCanvas.getContext('2d');

                    inputCanvasCtx.drawImage(img, 0, 0);
                    inputImageData = inputCanvasCtx.getImageData(0, 0, img.width, img.height);

                    document.getElementById('inputInfo').textContent = `(${img.width}×${img.height})`;
                    document.getElementById('runBtn').disabled = false;
                    document.getElementById('debugInfo').textContent += `\nImage loaded: ${img.width}×${img.height}`;
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        function updateProgressBar(percent) {
            const fill = document.getElementById('progressFill');
            fill.style.width = `${percent}%`;
            fill.textContent = `${Math.round(percent)}%`;
        }

        function highlightTile(x1, y1, x2, y2, progressText) {
            if (!inputCanvasCtx || !inputImageData) return;

            inputCanvasCtx.putImageData(inputImageData, 0, 0);

            inputCanvasCtx.fillStyle = 'rgba(0, 255, 0, 0.2)';
            inputCanvasCtx.fillRect(x1, y1, x2 - x1, y2 - y1);

            inputCanvasCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            inputCanvasCtx.lineWidth = 2;
            inputCanvasCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);

            document.getElementById('progress').textContent = progressText;
        }

        async function runTiledInference(imageData) {
            const {width, height} = imageData;
            const outputWidth = width * SCALE;
            const outputHeight = height * SCALE;

            const outputCanvas = document.getElementById('outputCanvas');
            outputCanvas.width = outputWidth;
            outputCanvas.height = outputHeight;

            const outputImageData = new ImageData(outputWidth, outputHeight);
            const step = TILE_SIZE - TILE_OVERLAP;
            const tilesY = Math.ceil(height / step);
            const tilesX = Math.ceil(width / step);
            const totalTiles = tilesY * tilesX;

            let tileCount = 0;

            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    if (isCancelled) {
                        throw new Error('Cancelled by user');
                    }

                    const y1 = y;
                    const x1 = x;
                    const y2 = Math.min(y1 + TILE_SIZE, height);
                    const x2 = Math.min(x1 + TILE_SIZE, width);

                    tileCount++;
                    const percent = (tileCount / totalTiles) * 100;
                    const progressText = `Processing tile ${tileCount}/${totalTiles}`;

                    highlightTile(x1, y1, x2, y2, progressText);
                    updateProgressBar(percent);

                    const patch = extractPatch(imageData, x1, y1, x2, y2);
                    const srPatch = await runModelWorker(patch);

                    const dy1 = y1 * SCALE;
                    const dx1 = x1 * SCALE;
                    placePatch(outputImageData, srPatch, dx1, dy1);

                    displayOutput(outputImageData);
                }
            }

            inputCanvasCtx.putImageData(inputImageData, 0, 0);
            return outputImageData;
        }

        function extractPatch(imageData, x1, y1, x2, y2) {
            const width = x2 - x1;
            const height = y2 - y1;
            const patch = new Float32Array(3 * height * width);

            for (let y = y1; y < y2; y++) {
                for (let x = x1; x < x2; x++) {
                    const srcIdx = (y * imageData.width + x) * 4;
                    const localY = y - y1;
                    const localX = x - x1;
                    const baseIdx = localY * width + localX;

                    patch[baseIdx] = (imageData.data[srcIdx] / 127.5) - 1.0;
                    patch[height * width + baseIdx] = (imageData.data[srcIdx + 1] / 127.5) - 1.0;
                    patch[2 * height * width + baseIdx] = (imageData.data[srcIdx + 2] / 127.5) - 1.0;
                }
            }

            return {data: patch, width, height};
        }

        function runModelWorker(patch) {
            return new Promise((resolve, reject) => {
                const {data, width, height} = patch;

                worker.postMessage({
                    type: 'runInference',
                    data: {patchData: Array.from(data), width, height}
                });

                const handler = function (e) {
                    const {type, data, error} = e.data;

                    if (type === 'inferenceResult') {
                        worker.removeEventListener('message', handler);

                        const {outputData, outWidth, outHeight} = data;
                        const rgbData = new Uint8ClampedArray(outHeight * outWidth * 3);

                        for (let i = 0; i < outputData.length; i++) {
                            const val = Math.max(-1, Math.min(1, outputData[i]));
                            rgbData[i] = Math.round((val + 1) * 127.5);
                        }

                        resolve({data: rgbData, width: outWidth, height: outHeight});
                    } else if (type === 'inferenceError') {
                        worker.removeEventListener('message', handler);
                        reject(new Error(error));
                    }
                };

                worker.addEventListener('message', handler);
            });
        }

        function placePatch(outputImageData, patch, dx1, dy1) {
            const {data, width: patchWidth, height: patchHeight} = patch;
            const outWidth = outputImageData.width;
            const outData = outputImageData.data;

            const channelSize = patchWidth * patchHeight;

            for (let y = 0; y < patchHeight; y++) {
                for (let x = 0; x < patchWidth; x++) {
                    const pixelIdx = y * patchWidth + x;

                    const rIdx = pixelIdx;
                    const gIdx = channelSize + pixelIdx;
                    const bIdx = 2 * channelSize + pixelIdx;

                    const outX = dx1 + x;
                    const outY = dy1 + y;

                    if (outX < outWidth && outY < outputImageData.height) {
                        const outIdx = (outY * outWidth + outX) * 4;

                        outData[outIdx] = data[rIdx];
                        outData[outIdx + 1] = data[gIdx];
                        outData[outIdx + 2] = data[bIdx];
                        outData[outIdx + 3] = 255;
                    }
                }
            }
        }

        function displayOutput(imageData) {
            const outputCanvas = document.getElementById('outputCanvas');
            const ctx = outputCanvas.getContext('2d');
            ctx.putImageData(imageData, 0, 0);
            
            const info = `(${imageData.width}×${imageData.height})`;
            document.getElementById('outputInfo').textContent = info;
        }

        // Run inference button
        document.getElementById('runBtn').addEventListener('click', async function () {
            if (!inputImageData || !worker) return;

            const runBtn = document.getElementById('runBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            runBtn.disabled = true;
            cancelBtn.style.display = 'inline-block';
            isCancelled = false;

            try {
                const outputData = await runTiledInference(inputImageData);
                if (!isCancelled) {
                    displayOutput(outputData);
                    document.getElementById('progress').textContent = '✅ Done!';
                    updateProgressBar(100);
                }
            } catch (err) {
                console.error("Inference failed:", err);
                if (!isCancelled) {
                    alert(`Inference failed: ${err.message}`);
                }
            } finally {
                runBtn.disabled = false;
                cancelBtn.style.display = 'none';
            }
        });

        // Cancel button
        document.getElementById('cancelBtn').addEventListener('click', function () {
            isCancelled = true;
            document.getElementById('progress').textContent = '❌ Cancelled';
        });
    </script>
</body>
</html>
